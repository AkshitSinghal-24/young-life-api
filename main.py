"""
Young Life Crowd Counter API
FastAPI application to count people in uploaded images 
and return the image with numbered detections.
"""

from fastapi import FastAPI, UploadFile, File, BackgroundTasks
from fastapi.responses import FileResponse, JSONResponse
from crowd_counter import CrowdCounter
import shutil
import os
import uuid
from pathlib import Path

app = FastAPI(title="Young Life Crowd Counter API")

# Global counter instance
counter = None

TEMP_DIR = Path("temp_uploads")
TEMP_DIR.mkdir(exist_ok=True)

RESULTS_DIR = Path("results")
RESULTS_DIR.mkdir(exist_ok=True)

@app.on_event("startup")
async def startup_event():
    global counter
    print("ðŸš€ Initializing Crowd Counter Model...")
    # Use the optimized settings: confidence=0.05
    # Note: imgsz is passed during inference in count()
    counter = CrowdCounter(confidence=0.05, model_path="weights/yolov8n-head.pt")
    print("âœ… Model loaded and ready!")

@app.get("/")
def read_root():
    return {"message": "Young Life Crowd Counter API is running. POST images to /count"}

def cleanup_file(path: str):
    """Delete a file in the background"""
    try:
        if os.path.exists(path):
            os.remove(path)
    except Exception as e:
        print(f"Error cleaning up {path}: {e}")

@app.post("/count")
async def count_people(file: UploadFile = File(...), background_tasks: BackgroundTasks = None):
    """
    Upload an image, count people, and return the annotated image
    """
    if not counter:
        return JSONResponse(status_code=500, content={"error": "Model not initialized"})

    # Generate unique ID for this request to avoid collisions
    request_id = str(uuid.uuid4())
    input_filename = f"{request_id}_{file.filename}"
    input_path = TEMP_DIR / input_filename
    
    # Save uploaded file
    with open(input_path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)
    
    try:
        # Define output directory for this request (or shared)
        # CrowdCounter saves to output_dir / {filename}_counted.jpg
        # We want to capture that file.
        
        # Run counting
        # Note: Using optimized imgsz=3008 as determined by experiments
        count = counter.count(
            str(input_path), 
            save_result=True, 
            output_dir=str(RESULTS_DIR),
            imgsz=3008
        )
        
        # Determine the output path generated by CrowdCounter
        # It appends "_counted" before the extension
        stem = Path(input_filename).stem
        suffix = Path(input_filename).suffix
        # CrowdCounter logic: output_file = output_path / f"{Path(image_path).stem}_counted.jpg"
        # Wait, CrowdCounter forces .jpg extension in the save logic:
        # output_file = output_path / f"{Path(image_path).stem}_counted.jpg"
        # So regardless of input extension, it saves as .jpg
        output_filename = f"{stem}_counted.jpg"
        output_path = RESULTS_DIR / output_filename
        
        if not output_path.exists():
            return JSONResponse(status_code=500, content={"error": "Failed to generate output image"})
            
        # Return the file
        # We use BackgroundTasks to clean up the input and output files after sending
        if background_tasks:
            background_tasks.add_task(cleanup_file, str(input_path))
            # Optional: keep results or clean them up? User might want to keep history?
            # For an API, usually we clean up unless stated otherwise.
            # Let's clean up to save space, assuming this is for on-demand processing.
            background_tasks.add_task(cleanup_file, str(output_path))
            
        return FileResponse(
            path=output_path, 
            filename=f"counted_{file.filename}.jpg",
            media_type="image/jpeg",
            headers={"X-People-Count": str(count)}
        )
        
    except Exception as e:
        # Cleanup input if failed
        if input_path.exists():
            os.remove(input_path)
        return JSONResponse(status_code=500, content={"error": str(e)})

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
